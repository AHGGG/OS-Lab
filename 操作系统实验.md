# 操作系统实验

## 1. 哲学家就餐问题
### 1.1. 问题描述
&emsp;&emsp;五个哲学家共用一张圆桌，分别坐在圆桌的5把椅子上，在圆桌上有五个碗和五只筷子，他们的生活方式是交替地进行思考和进餐。
&emsp;&emsp;当一个哲学家思考完毕开始进食时，他会试图取其左右最靠近他的筷子，只有拿到两只筷子时哲学家才能开始进餐。进餐完毕后，哲学家会放下筷子进行思考。

### 1.2. 实验要求
&emsp;&emsp;要求显示出每个哲学家的工作状态，如吃饭，思考。连续运行30次以上都未出现死锁现象。

### 1.3. 实验思路
哲学家就餐问题可能会面临着死锁或者活锁的两种情况：
1. 每个哲学家都拿着左手的筷子，永远都在等待右手边的筷子（或者相反）
2. 假设规定哲学家等待5min后还吃不上饭，那么他就放下手中的筷子，等待下一个5min再次进行尝试。当面临每个哲学家都同时拿起筷子，5min后再同时放下筷子时，系统将发生“活锁”

解决哲学家就餐问题主要有如下几个思路：
1. 当哲学家需要就餐时，需检查他左右两只筷子的状态，只有两只筷子均可用时，才允许他拿起筷子。否则即使是拿起了，他也不能进餐还会阻碍另一位哲学家进餐
2. 每一次至多允许四位哲学家竞争就餐，那么每次肯定可以保证一位哲学家就餐，在他就餐完毕后，释放筷子资源供其他哲学家就餐
3. 规定坐在奇数的哲学家先拿他左边的筷子，然后拿他右边的筷子；偶数号哲学家则相反，那么1、2将竞争1号筷子，3、4将竞争3号筷子，0号不需要竞争，必定会有一位哲学家拿到筷子  
    ![哲学家竞争筷子](http://sww-blog.oss-cn-chengdu.aliyuncs.com/MWeb/2022/06/02/16494162839479.jpg)

### 1.4. 实验代码
```c
semaphore chops[5] = {1, 1, 1, 1, 1};
semaphore count = 4;

void philosopher(int i) {
    while (true) {
        think();
        P(count);
        
        P(chops[i]);
        P(chops[(i+1)%5]);
        
        eat();
        
        V(chops[i]);
        V(chops[(i+1)%5]);
        
        V(count);
    }
}
```
注意编译时须引入头文件:
&emsp;&emsp;gcc philosopher.cpp -lpthread
```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

/*
筷子 --> 互斥锁
哲学家 --> 进程

先拿左边的筷子，再拿右边的筷子
先放左边的筷子，再放右边的筷子
采用只有四个哲学家竞争的方式，必定会有一个人吃上饭
*/

//声明互斥信号量, 五根筷子互斥使用，采用静态的方式进行初始化
pthread_mutex_t chopstick[5] = 
	{ PTHREAD_MUTEX_INITIALIZER ,PTHREAD_MUTEX_INITIALIZER ,
		PTHREAD_MUTEX_INITIALIZER,PTHREAD_MUTEX_INITIALIZER, PTHREAD_MUTEX_INITIALIZER };



//计数器，声明有多少个哲学家在拿筷子
int count = 0;

//哲学家拿筷子
void getChop(int i) {
	//当唤醒后，要去判断拿到筷子的人数是否达到四人
	while (count < 4) {
		
		// 上锁成功返回0，失败则堵塞
		int ret_trylock1 = pthread_mutex_lock(&chopstick[i-1]);
		
		//当有哲学家拿起第一个筷子的时候就表示有一个人在拿筷子了
		if (!ret_trylock1) {
			count++;
		}
		
		// 拿起左筷子后，开始拿右筷子
		int ret_trylock2 = pthread_mutex_lock(&chopstick[i%5]);
		
		// 两双筷子都拿到，可以开始吃饭了
		if (!ret_trylock1 && !ret_trylock2) {
			break;
		}
	}
}

//哲学家放下筷子开始思考
void layChop(int i)
{
	printf("哲学家%d已经进餐完毕，开始思考\n", i);
	
	// 吃完饭之后把筷子放下
	pthread_mutex_unlock(&chopstick[i - 1]);
	pthread_mutex_unlock(&chopstick[i % 5]);
	
	//释放两只筷子资源后就使count-1,表示此时吃饭的人减少了一位
	count--;
}

// 哲学家进程
void *philosophe(void *i) {
	while (true) {
		// 直接int index = (int)i 会报错，uintptr_t是Xcode编译下的修改方法
		int index = (uintptr_t)i;
		getChop(index);
		printf("哲学家%d开始进餐！\n", index);
		// 模拟进餐的时间
		sleep(2);
		layChop(index);
		// 模拟思考的时间
		sleep(1);
	}
	return NULL;
}

int main()
{
	//声明进程变量thread1
	pthread_t thread1,t1,t2,t3,t4,t5;
	
	//创建五个进程，直接以数字作为进程的编号
	//采用循环的方式创建会一直按顺序执行？
	pthread_create(&t1, NULL, philosophe, (void*)1);
	pthread_create(&t2, NULL, philosophe, (void*)2);
	pthread_create(&t3, NULL, philosophe, (void*)3);
	pthread_create(&t4, NULL, philosophe, (void*)4);
	pthread_create(&t5, NULL, philosophe, (void*)5);
	
	pthread_join(t1, NULL);
	pthread_join(t2, NULL);
	pthread_join(t3, NULL);
	pthread_join(t4, NULL);
	pthread_join(t5, NULL);
	return 0;
}
```
![运行截图](http://sww-blog.oss-cn-chengdu.aliyuncs.com/MWeb/2022/06/02/16494159278435.png)

## 2. 生产者/消费者问题的实现
### 2.1. 问题描述
&emsp;&emsp;有一群生产者在生产产品，并将这些产品提供给消费者去消费。为使生产者与消费者能够并发执行，在两者之间设置了一个具有n个缓冲区的缓冲池。  
&emsp;&emsp;生产者从文件中读取一个数据，并将它存放到一个缓冲区中，消费者从缓冲区中取走数据并输出。生产者与消费者之间必须保持同步，不允许消费者去空缓冲区中取，也不允许生产者向满缓冲区装

### 2.2. 实验要求
&emsp;&emsp;创建3进程（或者线程）作为生产者，4个进程（或者线程）作为消费者。创建一个文件作为数据源，文件中事先写入一些内容作为数据。

### 2.3. 实验思路
```c
semaphore mutex = 1;
semaphore empty = N;  // 空缓冲区数量
semaphore full = 0;  // 满缓冲区数量

producer() {
    while(1) {
        生产一个产品;
        
        p(empty);
        p(mutex);
        
        将产品放入缓冲区;
        V(mutex);
        V(full);
    }
}

customer() {
    while(1) {
        P(full);
        P(mutex);
        
        从缓冲区取出一个产品;
        V(mutex);
        V(empty);
    }
}
```
&emsp;&emsp;这个实验我做得有点问题，没读清题意...  
&emsp;&emsp;我是生产者随机生产一个字符放入文件中，然后消费者使用一个全局变量设置一个偏移量对文件内容进行读取，然后因为有信号量机制的原因肯定能控制有效内容的大小  
&emsp;&emsp;没看到还要将内容放到缓冲区中...

### 2.4. 实验代码
同上编译的时候需要带上
&emsp;&emsp;gcc producer.cpp -lpthread
```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <time.h>
#include <pthread.h>
#include <semaphore.h>


//定义缓冲区大小为5 生产者3个 消费者4个
#define N 5
#define PRODUCER_NUM  3
#define CONSUMER_NUM  4

char nextp[1];
int out = 0;

sem_t mutex, full, empty;

void* Producer(void* arg) {
    // 获取生产者编号
    int proID = (uintptr_t)arg;

    while (1) {
        nextp[0] = rand() % 26 + 'A';
        //查看缓冲区是否有空
        sem_wait(&empty);
        //加锁
        sem_wait(&mutex);

        //模拟生产
        sleep(1);

        // 每次生产产品从文件末尾追加
        FILE *fp;
        fp = fopen("./file.txt", "a+");
        fputs(nextp, fp);
        fclose(fp);
        printf("生产者%d号，放了产品%c\n", proID, nextp[0]);
        //解锁
        sem_post(&mutex);
        //满的位置加一个
        sem_post(&full); 
    }
}

void* Consumer(void* arg) {
    //获取消费者编号
    int conID = (uintptr_t)arg;
    while (1) {
        //查看缓冲区是否有内容
        sem_wait(&full);
        //解锁
        sem_wait(&mutex);

        //消费一个产品，使用全局的out变量使用fseek函数从out偏移处取产品
        FILE *fp;
        fp = fopen("./file.txt", "rt");
        fseek(fp, out, SEEK_SET);

        char ch = fgetc(fp);
        printf("消费者%d号，消费了产品%c\n", conID, ch);
        out++;

        //消费中
        sleep(1);
        //解锁
        sem_post(&mutex);
        //空的位置加一个
        sem_post(&empty);
    }
}

int main() {
    //初始随机函数
    srand(time(0));

    //互斥信号量mutex，控制缓存区的互斥访问
    sem_init(&mutex, 0, 1);
    //同步信号量full，记录缓存区中已使用的数
    sem_init(&full, 0, 0);
    //同步信号量empty，记录缓存区未使用的数
    sem_init(&empty, 0, N);

    //声明消费者、生产者进程
    pthread_t p[PRODUCER_NUM], c[CONSUMER_NUM];
    int i;
    
    //创建生产者、消费者进程放入进程池，将i作为编号进行传参
    for (i = 0; i < PRODUCER_NUM; i++)
        pthread_create(&p[i], NULL, Producer, (void*)i);
    for (i = 0; i < CONSUMER_NUM; i++)
        pthread_create(&c[i], NULL, Consumer, (void*)i);
        
    //等待生产者、消费者进程运行结束
    for (i = 0; i < PRODUCER_NUM; i++)
        pthread_join(p[i], NULL);
    for (i = 0; i < CONSUMER_NUM; i++)
        pthread_join(c[i], NULL);
    return 0;
}
```

![实验结果](http://sww-blog.oss-cn-chengdu.aliyuncs.com/MWeb/2022/06/02/16538292279664.png)

### 2.5. debug纪实
&emsp;&emsp;有同学在使用pthread_join()函数的时候遇到了几个问题，他想在这个函数之后通过printf输出一段结束语句，但是怎么也无法输出  
&emsp;&emsp;同时，他还想让生产者在读取到文件结尾处退出生产者进程，然后整个主程序回收分配给进程的资源  
&nbsp;
&emsp;&emsp;通过主程序采用阻塞的方式回收线程，必须要有一个线程自动返回的动作，因此在生产者or消费者线程中可以这样写：  
```c
// 文件中数据拿完则结束子进程，返回主进程
if(out == EOF) {
	printf("\n%d exit\n", id);
	return NULL;
}
```
&emsp;&emsp;但是回收资源的这种写法存在一个逻辑问题，因为三个生产者争相读到文件末尾后进行自行返回的操作，那么这个EOF应该是要放到buffer中供消费者取出来判断的（消费者读到EOF后退出），那么题目是3个生产者4个消费者，就会出现empty和full不匹配的情况，剩余的最后一个消费者向进入读EOF的时候已经没有full的空间了，所以采用这种方法并不能完全回收分配的资源  
![生产者、消费者分别回收 222222为结束输出](http://sww-blog.oss-cn-chengdu.aliyuncs.com/MWeb/2022/06/02/jie-ping20220529-202951.png)


## 3. 基于管道的进程间数据传输
### 3.1. 问题描述
&emsp;&emsp;在Linux系统中使用系统调用fork()创建两个子进程，使用系统调用pipe()建立一个管道，两个子进程分别向管道各写一句话：  
&emsp;&emsp;Child process 1 is sending a message!   
&emsp;&emsp;Child process 2 is sending a message!  
&emsp;&emsp;父进程从管道中读取来自两个子进程的信息，显示在屏幕上，然后分别结束两个子进程的运行

### 3.2. 实验要求
1. 父进程先接收来自子进程P1发来的消息，然后再接收子进程P2的消息
2. 在Linux平台下实现

### 3.3. 实验思路
1. 主要掌握两个函数的用法：
    ```c
    int pipe(int pipefd[2]); 
        fd[0]->读端  fd[1]->写端
        
    pid_t pid = fork();
        pid = 0 子进程
        pid > 0 父进程
        pid < 0 创建失败
    ```
1. C语言在Linux上编程的行缓冲及列缓冲机制
    ```c
    #include <unistd.h>
    #include <stdio.h>
    int glob = 6;
    char buf[ ] = "a write to stdout\n";
    int  main(void)
    {
        int var = 88;
        pid_t pid;
        if (write(STDOUT_FILENO, buf, sizeof(buf)-1) != sizeof(buf)-1)
            printf("write error");
        printf("before fork\n"); 
        if ( (pid = fork()) < 0) printf("fork error");
        else if (pid == 0) {
            glob++, var++;
            printf("pid = %d, glob = %d, var = %d\n", getpid(), glob, var);}
        else{
            sleep(2); 
            printf("pid = %d, glob = %d, var = %d\n", getpid(), glob, var);
        }
    }
    ```
    ![代码输出结果](http://sww-blog.oss-cn-chengdu.aliyuncs.com/MWeb/2022/06/02/16541549429934.jpg)
    &emsp;&emsp;可以看到第二次输出重定向到文件中的时候，“before fork”输出了两次，但是不是因为子进程在拷贝后重复执行了有关“before fork”的printf函数，而是Linux中的全缓冲机制。  
    &emsp;&emsp;如果直接将输出结果打印在终端，此时Linux采用的是行缓冲机制，通过读取\n换行符来清空输出缓冲打印到屏幕中  
    &emsp;&emsp;如果将结果不直接输出到终端，那么这时将采用全缓冲机制，父进程通过fork()得到子进程后，子进程会拷贝父进程的输出缓冲，由于父进程还没到达程序末尾，因此还没将“before fork”输出，其输出缓冲中还含有“before fork”，因此子进程会将其拷贝过去，直到子进程到达程序末尾先输出“before fork”，再输出有关于glob、var的语句，再是父进程输出  
2. 管道机制  
    &emsp;&emsp;在管道中习惯不用哪端就将哪端在开始的关掉，在本次实验中，父进程只用到了读端子进程只用到了写端，因此在父进程中需要  
    ```c
    close(fd[1]);
    ```
    &emsp;&emsp;在子进程中需要
    ```c
    close(fd[0]);
    ```
    &emsp;&emsp;之所以需要关闭是因为在Linux中的内存回收需要自己申请自己回收，系统不会自动销毁。如果一开始不关闭的话，那么在父进程使用完读端想将其销毁的时候是无法销毁的，因为子进程还占用着

### 3.4. 实验代码
```c
#include <stdio.h>#include <unistd.h>#include <sys/wait.h>#include <string.h>#define SSIZE 50;int main(){	int fd[2], ret;	pid_t pid;		// 创建管道	if ((ret = pipe(fd)) == -1) {		printf("管道创建失败");		return -1;	}		// 创建子进程1	char str_1[] = "Child process 1 is sending a message!";	char str_2[] = "Child process 2 is sending a message!";		pid = fork();	if (pid == -1) {		printf("创建子进程1失败");		return -1;	} else if (pid ==0) {		close(fd[0]);		sleep(1);		write(fd[1], str_1, strlen(str_1)+1);		printf("%d 号子进程完成写入 %s\n", getpid(), str_1);	} else {		pid = fork();		if (pid == -1) {			printf("创建子进程2失败");			return -1;		} else if (pid == 0){			close(fd[0]);			sleep(1);			write(fd[1], str_2, strlen(str_1)+1);			printf("%d 号子进程完成写入 %s\n", getpid(), str_2);		} else {			sleep(3);			char str_3[100];			close(fd[1]);			read(fd[0], str_3, strlen(str_1)+1);			printf("父进程完成读取:%s\n", str_3);			read(fd[0], str_3, strlen(str_2)+1);			printf("父进程完成读取:%s\n", str_3);			}	}}
```
![实验结果](http://sww-blog.oss-cn-chengdu.aliyuncs.com/MWeb/2022/06/02/16494257737234.png)

### 3.5. debug纪实
![使用printf出错](http://sww-blog.oss-cn-chengdu.aliyuncs.com/MWeb/2022/06/02/90048e8e8acbe8dd1d65d6ba1af19d80.png)

&emsp;&emsp;同学说一开始使用write函数将两个线程中的数据读入管道，但是在使用printf读出的时候只能输出一个进程的语句  
&emsp;&emsp;一开始我以为是printf行缓冲与全缓冲的原因，但是我后来调试的时候发现buf读出的长度是对的，然后发现是printf在输出字符串的时候遇到'\0'就会结束输出了，而对于字符串的话会在后面默认加'\0', 因此可以用两种方法改进：  
```c
// 将字符串的'\0'删掉
write(fd[1],c1,sizeof(c1)-1);
// 再读
read(fd[0], buf, sizeof(buf));
printf("%s\n", buf);

// 不用删，按字符读
write(fd[1],c1,sizeof(c1));
for (int i=0; i<sizeof(c1)+sizeof(c2); i++)
	printf("%c", buf[i]);
```

## 4. 文件状态测试
### 4.1. 问题描述
&emsp;&emsp;编写一个SHELL程序，动态检测指定文件的状态信息，当文件的大小发生改变时，给出提示信息，并继续进行检测。

### 4.2. 实验要求
1. 在SHELL中有对屏幕显示内容及格式的控制方法
2. 要有UNIX中基本cut、sed、awk命令的使用

### 4.3. 实验思路
1. 运行程序，得到用户想要监测的文件名
2. 若文件不存在，则显示友好的提示信息，程序正常退出；若能找到，程序继续运行
3. 通过ls -l获得文件的大小信息，并主要对此信息进行监测，可使用cat sed awk函数进行信息的提取
4. 每隔5s对文件大小进行一次检查，如果文件大小改变了，那么我们在屏幕上显示信息，累计改变两次，程序退出，如若连续十次未改变，程序也退出

### 4.4. 实验代码
运行：
&emsp;&emsp;./file.sh

```bash
#!/bin/bash

# 动态检测指定文件的状态信息，当文件的大小发生改变时，给出提示信息，并继续进行检测

# 检查命令格式，如果其后参数个数超过1个，程序终止 否则让用户输入文件名
if [ $# != 0 ]
then
	echo "Usage: file_monitor"
	exit 1
else
	clear
	echo -n "Input filename: "
fi

# 获取文件名
read filename

# 获取文件初始大小
# ls -l显示信息的第5列为文件的大小，将内容输入到管道
# cut -d ' ' -f5以空格分隔，得到第五列的信息
filesize=`ls -l ${filename} | cut -d' ' -f5`
# 数字属性控制颜色输出
echo -e "file \033[034m${filename}\033[0m size is \033[036m${filesize}\033[0m"

# 监测文件大小变化
checksize()
{
	nowsize=`ls -l ${filename} | cut -d' ' -f5`
	if [ "${nowsize}" == "${filesize}" ]
	then
		echo -e "file \033[034m${filename}\033[0m size \033[036mnot changed\033[0m"
		return 0
	else
		echo -e "file \033[034m${filename}\033[0m size \033[031mchanged\033[0m"
		filesize="${nowsize}"
		echo -e "file \033[034m${filename}\033[0m size is \033[036m${filesize}\033[0m"
		return 1
	fi
}

# Main
# 声明整型变量计数
declare -i count_time=0
declare -i changed_time=0

# 当文件连续十次监测无改变或改变两次时监测结束
while [ ${count_time} -ne 10 -a ${changed_time} -ne 2 ]
do
	sleep 5
	checksize
	# 获得checksize的返回值
	if [ $? -eq 0 ]
	then
		((count_time++))
	else
		count_time=0
		((changed_time++))
	fi
done

# 提示用户并清屏退出
if [ ${count_time} -eq 10 ]
then
	echo "aim file not changed for 50s!"
else
	echo "aim file changed twice!"
fi
clear
```

![实验截图](http://sww-blog.oss-cn-chengdu.aliyuncs.com/MWeb/2022/06/02/16494732226445.png)

### 4.5. debug纪实
&emsp;&emsp;救命！！！ 这堂课全是**标点符号**写错的！！！  
&emsp;&emsp;是  `  不是  '  
&emsp;&emsp;是  -  不是  —  
&nbsp;
&emsp;&emsp;还有一个同学是每次文件变化都没有监测出来，这个比较好改，因为他每次把监测结果输出重定向到一个文件中，再进行的while判断。然后每次他都读取的是文件而不是重新获取新的改变值，这个是粗心犯的错了

## 5. 用户登录动态监测
### 5.1. 问题描述
&emsp;&emsp;编写一个用户监测程序usr_monitor, 其运行格式为：
&emsp;&emsp;usr_monitor  username
&emsp;&emsp;其中username是用户指定的任意一个用户名

### 5.2. 实验要求
&emsp;&emsp;程序运行时首先列出当前系统中的已登录用户的名单，再检查指定用户是否已登录。如果已登录，则显示相应信息；如果未登录，则等待该用户登录，直到指定用户登录进入系统为止。

### 5.3. 实验思路
1. 运行程序，获取用户登录的用户名
2. 通过who命令，得到当前系统中的用户名单并用变量users保存下来
3. 检查用户名是否在users中，如果有显示登录信息
4. 否则一直循环等待用户登录

### 5.4. 实验代码
可能遇到权限问题：
&emsp;&emsp;sudo chmod -R 777 login.sh运行格式：
&emsp;&emsp;./login.sh swenw

```bash
#!/bin/sh
# 运行格式为 usr_monitor username
# 其中 username 是用户指定的任意用户名
# 程序首先列出当前系统已登录的用户名单，再检查该用户是否已登录。
# 如果已登录，则显示对应信息；如果未登录，则等待该用户登录，直到指定用户登录到系统为止。

# 检查输入格式是否正确
if [ $# != 1 ]
then
    echo "Usage: usr_monitor username"
    exit 1
else
    username=$1
fi

# 查找目标用户是否登录
check_user()
{
    # 将who的内容输出到变量users中，打印现在登录系统的用户名单
    who > users
    echo -e "\033[036mLogin users:\033[0m"
    echo `users`
    echo '------------------------------------------------------------------'

    # 检查用户是否登录
    # 在users中查找是否存在username这个人
    check=`users | grep ${username}`
    rm users
    # -n测试非零长度，查找结果不为空
    if [ -n "${check}" ]
    then
        # -e 输出时处理特殊字符，不按文本输出
        echo -e "user \033[034m${username}\033[0m is \033[036mlog on\033[0m"
        return 0
    else
        # -n 输出时不换行
        echo -e -n "\033[031mwaiting\033[0m user \033[034m${username}\033[0m..."
        return 1
    fi
}

# Main
# 未登录，一直等待，直到指定的用户登录系统
check_user
while [ $? -eq 1 ]
do
    sleep 5
    echo -e '\n------------------------------------------------------------------'
    check_user
done
```

![监控Amy 并使用ssh远程登录Amy用户](http://sww-blog.oss-cn-chengdu.aliyuncs.com/MWeb/2022/06/02/16541543907973.jpg)


### 5.5. debug纪实
&emsp;&emsp;有同学说采用grep命令的时候，会遇到不完全匹配的情况，就是说能在swenw中匹配到sw  
&emsp;&emsp;查了下资料，这个时候可以使用-w来进行一个全字匹配，这个时候在结果中只会显示全字符合的列

## 6. 系统命令的实现
### 6.1. 实验要求
1. 利用POSIX API（文件操作也可以使用ANSI C标准I/O库）编程实现cp –r命令，支持将源路径（目录）中的所有文件和子目录，以及子目录中的所有内容，全部拷贝到目标路径（目录）中。
3. 掌握UNIX/Linux目录操作方法，包括打开目录、关闭目录、读取目录文件
4. 掌握UNIX/Linux文件属性获取方法，包括三个获取UNIX/Linux文件属性的函数、文件属性解析的重要数据结构及实现机制
5. 掌握POSIX与ANSI C文件I/O操作方法，包括打开文件、关闭文件、创建文件、读写文件、定位文件

### 6.2. 实验思路
1. 在C代码中如何在可运行文件后跟参数
    ```c
    int main(int argc, char* argv[])
    ```
    运行格式可运行文件名 + 参数（参数以空格分隔）  
    参数以字符串形式进行接收  
    真正的argc为参数个数+1，因为第一个参数是可执行文件名  
2. 文件及目录信息获取
    ```c
    struct stat  // 文件状态信息
    int stat(const char *path, struct stat *buf);
    ```
    stat结构体中，在本次实验中最关心的是st_mode这个属性，可以采用S_ISDIR这个宏函数判断其是目录文件还是普通的文件
3. 遍历目录项
    ```c
    struct dirent  // 目录信息
    
    struct dirent * readdir(DIR * dir);  
    DIR * opendir(const char * name);  // 返回一个目录流
    ```
    遍历函数的参数是一个目录流指针，因此需要先使用opendir函数将目录路径打开，得到一个目录流指针，然后再将其作为readdir的参数将其遍历  
    &nbsp;
    在dirent结构体中，我们需要关注的属性是d_name，通过d_name可以得到递归遍历路径，并且注意需要排除 . 及 .. 的不需要拷贝的文件  
1. 递归思路
    对源路径进行判断的时候，我们需要
    * 判断其stat是一个目录文件还是一个普通文件
    * 如果是目录文件，使用readir进行遍历
    * 判断其第一个目录项是一个目录文件还是一个普通文件
    * 如果是目录文件，使用readir进行遍历
    
    因此递归的思路出来了，递归的出口应该有两个，一个是遇到是普通文件时直接拷贝复制即可，二是遇到遍历目录项结束时  
    但是文件的拷贝不能是普通的直接将其拷贝到目的路径下，因为这时候会丧失源目录的树状结构，这时候应该在遍历过程中记录其路径，采用源路径 + 文件名拼接的方式在递归过程中记录  
    ```c
    while((direntp=readdir(dirpointer))!=NULL)
    {
    	// 当前目录及上一级目录，跳过
    	if(strcmp(direntp->d_name,".")==0||strcmp(direntp->d_name,"..")==0)
    		continue;
    	// 拼接新的路径为/dirpath_from/direntp->d_name
    	sprintf(dirpath_from,"%s/%s",dirpath_from,direntp->d_name);
    	// 递归复制子文件夹内的文件
    	copy(dirpath_from,dirpath_to);
    	// 回到递归开头，继续往后遍历
    	sprintf(dirpath_from,"%s",path1);
    }
    ```


### 6.3. 实验代码
编译：
&emsp;&emsp;gcc copy.cpp -o copy运行，其中one two是当前目录的两个文件夹名字
&emsp;&emsp;./copy one two

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>
#include <string.h>
#include <fcntl.h>
// 普通文件复制
void copy_regular_file(char dirpath_from[],char dirpath_to[])
{
	int fd1,fd2,size;
	char buf[200]="";
	char dir1[255]="";
	char dir2[255]="";

	struct stat file;
	sprintf(dir1,"%s",dirpath_from);
	sprintf(dir2,"%s",dirpath_to);
	sprintf(dir2,"%s/%s",dir2,dir1);

	if(stat(dir1,&file)==-1)
	{
		printf("Can not get info of %s\n",dir1);
		exit(-1);
	}

	if((fd1=open(dir1,O_RDONLY))==-1)
	{
		printf("Can not open file %s\n",dir1);
		exit(-1);
	}

	if((fd2=creat(dir2,file.st_mode))==-1)
	{
		printf("Can not open file %s\n",dir2);
		exit(-1);
	}
		
	// size表示从fd的当前位置复制最多200个字节到buf实际传输的字节数量
	while((size=read(fd1, buf, 200))!=0)
		// write表示从buff复制fd2最多复制size个字节
		if(write(fd2, buf, size) != size)
			printf("Write error");
	
	close(fd1);
	close(fd2);
	return;
}


DIR *copy(char dirpath_from[],char dirpath_to[])
{
	DIR *dirpointer;
	char path1[255]="";
	char path2[255]="";
	char path3[255]="";
	
	// 打开文件夹存放的结构体指针
	struct dirent *direntp;
	// 存放文件或者是文件夹的属性
	struct stat info;

	strcpy(path1,dirpath_from);
	strcpy(path2,dirpath_to);

	// 通过dirpath_from获取文件信息并将结果保存到info中
	if(stat(dirpath_from,&info)!=-1)
	{
		//如果dirpath_from是一个目录
		if((info.st_mode&0170000)==0040000)
		{
			sprintf(path3,"%s/%s",dirpath_to,dirpath_from);
			// 创建dirpath_to/dirpath_from的路径，0777表示权限
			if(mkdir(path3,0777)==-1)
			{
				printf("Can not create dir %s\n",path3);
				exit(-1);
			}

			if((dirpointer=opendir(dirpath_from))==NULL)
			{
				printf("Can not open dir %s\n",dirpath_from);
				exit(-1);
			}
			
			// 读目录，每执行一次，返回指向当前读取目录项结构的指针
			while((direntp=readdir(dirpointer))!=NULL)
			{
				// 当前目录及上一级目录，跳过
				if(strcmp(direntp->d_name,".")==0||strcmp(direntp->d_name,"..")==0)
					continue;
				// 拼接新的路径为/dirpath_from/direntp->d_name
				sprintf(dirpath_from,"%s/%s",dirpath_from,direntp->d_name);
				// 递归复制子文件夹内的文件
				copy(dirpath_from,dirpath_to);
				// 回到递归开头，继续往后遍历
				sprintf(dirpath_from,"%s",path1);
			}
		}

		else // 如果dirpath_from是一个文件，直接按照普通文件复制
		{
			copy_regular_file(dirpath_from,dirpath_to);
		}
	}
	return 0;
}


int main(int argc,char *argv[])
{
	DIR *dirp;
	char path1[255]="";
	char path2[255]="";
	
	// 将第一个、第二个参数保存至path1 path2
	sprintf(path1,"%s",argv[1]);
	sprintf(path2,"%s",argv[2]);
	
	if(argc<3)
	{
		printf("Please check the usage...\n");
		exit(-1);
	}
	
	dirp=copy(path1,path2);
	closedir(dirp);
	return 0;
}
```
![运行结果 直接将one目录拷贝到了two目录下](http://sww-blog.oss-cn-chengdu.aliyuncs.com/MWeb/2022/06/02/16494893127987.png)
